# -*- coding: utf-8 -*-
"""
Created on Sun Jan 26 20:31:48 2020

@author: maria
"""

'''
ECE276A WI20 HW1
Stop Sign Detector
'''
#correct one-21078698.88
import os, cv2
#from matplotlib import pyplot as plt
import numpy as np
#from skimage.measure import label, regionprops
#from matplotlib.path import Path

class StopSignDetector():
    def __init__(self):

        #self.w=np.array([[18208126.96],[-21078698.88],[-19452428.6]])#final weights
        self.w=np.array([[5323.04],[-7758.56],[-4423.99]])

        
        
    def segment_image(self, img):
        x=img.copy()
        x=cv2.cvtColor(x,cv2.COLOR_BGR2RGB) #change color space to RGB
        
        x=np.reshape(x,(x.shape[0]*x.shape[1],x.shape[2])) #arranging test image into Nx3 matrix
        
        product=np.dot(x,self.w) #finding the dot product <x,w>
        
        x=np.where(product>=0,1,0) #classification step
        
        x = x.astype(np.uint8)
        x=np.reshape(x,(img.shape[0],img.shape[1])) #reshaping back to 2d

        return x
        #raise NotImplementedError

    def get_bounding_box(self, img):
        '''
            Find the bounding box of the stop sign
            call other functions in this class if needed

            Inputs:
                img - original image
            Outputs:
                boxes - a list of lists of bounding boxes. Each nested list is a bounding box in the form of [x1, y1, x2, y2]
                where (x1, y1) and (x2, y2) are the top left and bottom right coordinate respectively. The order of bounding boxes in the list
                is from left to right in the image.

            Our solution uses xy-coordinate instead of rc-coordinate. More information: http://scikit-image.org/docs/dev/user_guide/numpy_images.html#coordinate-conventions
        '''
        # YOUR CODE HERE
        boxes=[]
        img1=img.copy()
        mask=self.segment_image(img1)
        mask1=mask
        
        ret,thresh1=cv2.threshold(mask1,0,255,cv2.THRESH_BINARY) #creating uint8 image
        
        thresh=cv2.GaussianBlur(thresh1,(5,5),0) #applying blur to smooth out the edges.

        contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) #finding the contours in the segmented mask

        
        cnts=sorted(contours, key = cv2.contourArea, reverse = True)[:2] #sorting the contours area-wise in desecending order and selecting the three largest.

        
        for cnt in cnts: #iterating through the three largest contours
            approx = cv2.approxPolyDP(cnt,0.01*cv2.arcLength(cnt,True),True) #approximating a polygon

            if (len(approx)>=5):
                ellipse=cv2.fitEllipse(approx)   
                center,axes,orientation=ellipse
                majoraxis=max(axes)
                minoraxis=min(axes)
                eccentricity=np.sqrt(1-(minoraxis/majoraxis)**2) #stop sign score calculation
                if len(approx)>=8: #if polygon has 8 or more sides, let it pass.
                    if eccentricity<0.4:
                        (x,y,w,h)=cv2.boundingRect(approx)  #getting the bounding rectangle coordinates
                        if w*h>300:
                            #points=[x,img.shape[0]-(y+h),x+w,img.shape[0]-y] #converting them to cartesian coordinates.
                            points=(int(x),int(y),int(x+w),int(y+h))
                            boxes.append(points)
                    

        #raise NotImplementedError
        boxes.sort(key=lambda x: x[0])
        #print(boxes)
        
        return boxes


# if __name__ == '__main__':
#     folder = "C:\\Users\\maria\\Desktop\\UCSD - masters\\Winter 2020\\ECE_276A\\Homeworks\\HW1_new\\ECE276A_PR1\\ECE276A_PR1\\hw1_starter_code\\test_set"
#     my_detector = StopSignDetector()
#     for filename in os.listdir(folder):
#         #read one test image
#         img = cv2.imread(os.path.join(folder,filename))
#         #cv2.imshow('image', img)
#         #cv2.waitKey(0)
#         #cv2.destroyAllWindows()
#         mask_img = my_detector.segment_image(img)
#         # cv2.imshow('image',mask_img)
#         # cv2.waitKey(0)
#         # cv2.destroyAllWindows()
#         plt.imshow(mask_img,cmap="gray")
#         plt.show()

#         #Display results:
#         #(1) Segmented images
       
#         #(2) Stop sign bounding box
#         boxes = my_detector.get_bounding_box(img)
#         print('box',boxes)
#         #The autograder checks your answers to the functions segment_image() and get_bounding_box()
#         #Make sure your code runs as expected on the testset before submitting to Gradescope

